<!DOCTYPE html>
<html><head><link rel="stylesheet" href="https://s.brightspace.com/lib/fonts/0.6.1/fonts.css"></head><body style="color: rgb(32, 33, 34); font-family: Lato, sans-serif; font-size: 12px;"><p><span style="font-size: 20px;"><strong>Project Development Guidance: Week 4</strong></span></p>
<p><span style="font-size: 16px;">Begin by reviewing any feedback to your concept memo.&nbsp; Address any issues (e.g., where additional details or clarification may be required) before continuing.</span></p>
<p><span style="font-size: 16px;"><strong>Designing the Main Data Structure</strong></span></p>
<p><span style="font-size: 16px;">Once your project concept has been approved, an early step should be to design the data structure for representing problem instances.&nbsp; This data structure will be used to represent the problem's configuration at each step of the solution process.&nbsp; For example, if the project was a Sudoku puzzle solver, the data structure would represent the state of the puzzle, with some cells filled in and other cell contents yet to be determined.</span></p>
<p><span style="font-size: 16px;">The design of the data structure will be problem-specific.&nbsp; However, during the design process, it will be helpful to consider how an instance of this data structure will be queried and modified as the solution process unfolds.&nbsp; The heart of the imperative version will likely be a "solve" procedure similar to the one summarized below (in Python-like pseudo-code):</span></p>
<p style="padding-left: 40px;"><span style="font-size: 14px;"><span style="font-family: 'courier new', courier, sans-serif;">def solve(p: Problem) -&gt; bool:<br></span><span style="font-family: 'courier new', courier, sans-serif;"></span></span></p>
<p style="padding-left: 80px;"><span style="font-size: 14px; font-family: 'courier new', courier, sans-serif;">if p solved: return True</span></p>
<p style="padding-left: 80px;"><span style="font-size: 14px; font-family: 'courier new', courier, sans-serif;">for each move in set of next possible moves for p:&nbsp; &nbsp; &nbsp;# a choice point in the search</span></p>
<p style="padding-left: 120px;"><span style="font-size: 14px; font-family: 'courier new', courier, sans-serif;">apply move to p to get p'</span></p>
<p style="padding-left: 120px;"><span style="font-size: 14px; font-family: 'courier new', courier, sans-serif;">let solved = solve(p')&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# does a particular choice lead to a solution?</span></p>
<p style="padding-left: 120px;"><span style="font-size: 14px; font-family: 'courier new', courier, sans-serif;">if solved: return True&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# yes: done</span></p>
<p style="padding-left: 120px;"><span style="font-size: 14px; font-family: 'courier new', courier, sans-serif;">undo move (restores p from p')&nbsp; &nbsp; &nbsp;# no:&nbsp; iteratively consider other options (if any)</span></p>
<p style="padding-left: 80px;"><span style="font-size: 14px; font-family: 'courier new', courier, sans-serif;">return False&nbsp; &nbsp; &nbsp;# if none work, backtrack to an earlier choice point</span></p>
<p><span style="font-size: 16px;">This is a recursively defined procedure that implements a depth-first search with backtracking.&nbsp; It explores a search space of choice points, looking for a sequence of choices that solve the problem while satisfying any constraints.&nbsp; (You can think of the search space as a tree that the procedure explores in a depth-first fashion, until a solution is found or the space has been exhaustively searched - in the latter case no solution is possible.)</span></p>
<p><span style="font-size: 16px;">Above, "p" represents a "Problem" instance.&nbsp; Of course, you'll use self-documenting variable, type, and procedure names that are more appropriate to your specific project.</span></p>
<p><span style="font-size: 16px;">As you examine the above algorithm, note the various operation that your Problem type will likely need to support:</span></p>
<ul>
<li><span style="font-size: 16px;">A function that determines if the problem instance is in a solved state</span></li>
<li><span style="font-size: 16px;">A method of enumerating the set of next possible "moves" at a given choice point in the search</span></li>
<li><span style="font-size: 16px;">A method for updating the problem instance by applying the chosen move</span></li>
<li><span style="font-size: 16px;">A method for restoring the problem instance by undoing the previously chosen move</span></li>
</ul>
<p><span style="font-size: 16px;">A good data structure design is one that affords efficient, clear algorithms for performing these (and other required) operations on problem instances.</span></p>
<p><span style="font-size: 16px;">Although you're probably not ready to implement the "solve" algorithm yet, thinking carefully now about the algorithmic details of these operations will help you to design the data structure.&nbsp; Good design choices will greatly improve the quality of the program and will facilitate work at subsequent stages of development.&nbsp; Don't assume that your first or the most obvious design is will be the best one.</span></p>
<p><span style="font-size: 16px;">Compare the above pseudo-code with the code in the imperative solution of the <a href="/d2l/common/dialogs/quickLink/quickLink.d2l?ou=116256&amp;type=content&amp;rcode=E595AE0C-8A63-41EC-9004-7FB5722070E0-278304" target="_blank" rel="noopener">Eight Queens Case Study</a> to see a (very simple) example of this type of technique.&nbsp; Note the design of the "Board" data type and how board instances are queried and modified throughout the program.</span></p>
<p><strong><span style="font-size: 16px;">Anticipating Next Steps</span></strong></p>
<p><span style="font-size: 16px;">Upcoming development work will include (among other possible tasks):</span></p>
<ol>
<li><span style="font-size: 16px;">Developing a module that parses input data to build the initial problem instance (and that detects invalid input)</span></li>
<li><span style="font-size: 16px;">Developing a module that writes a solution to the output, given a solved problem instance</span></li>
<li><span style="font-size: 16px;">Developing the module that encapsulates the data type described above. This module exports the collection of problem instance query/modifier procedures that allow client modules to manipulate problem instances (these include the methods described in the previous section)</span></li>
<li><span style="font-size: 16px;">Developing the main module that integrates all of the above into a working program</span></li>
</ol>
<p><span style="font-size: 16px;">It isn't too early to start thinking about the program's high-level design architecture, including about the role of each of these modules and how they will relate to each other.</span></p>
<p><span style="font-size: 16px;">Note that the above pseudo-code does not include any attempts to improve the performance of the search process.&nbsp; Some guidance on this may be given later.</span></p></body></html>